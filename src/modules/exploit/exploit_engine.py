#!/usr/bin/env python3
"""
Exploit Engine - Executes exploits with intelligent path adaptation
"""
import re
import requests
import time
from typing import Dict, List, Optional
from urllib.parse import urljoin
from utils.logger import logger


class ExploitEngine:
    """Execute exploits with dynamic path adaptation and validation"""
    
    def __init__(self, target: str, timeout: int = 10, dry_run: bool = False):
        self.target = target.rstrip('/')
        self.timeout = timeout
        self.dry_run = dry_run
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'BugBountyTool/1.0 (Security Research)'
        })
        self.results = []
        
    def execute_exploit(self, exploit: Dict, discovered_paths: List[Dict] = None) -> Dict:
        """
        Execute an exploit template
        
        Args:
            exploit: Exploit template from ExploitDB
            discovered_paths: Optional list of discovered paths to combine with exploit paths
        
        Returns:
            Dictionary with exploitation results
        """
        logger.info(f"Executing exploit: {exploit.get('name')} ({exploit.get('cve', 'Generic')})")
        
        result = {
            'exploit_name': exploit.get('name'),
            'cve': exploit.get('cve'),
            'type': exploit.get('type'),
            'severity': exploit.get('severity'),
            'success': False,
            'successful_payloads': [],
            'failed_payloads': [],
            'proof': []
        }
        
        if self.dry_run:
            logger.info("[DRY RUN] Would execute exploit, but dry_run=True")
            result['dry_run'] = True
            return result
        
        # Execute each payload in the exploit
        for payload in exploit.get('payloads', []):
            payload_result = self._execute_payload(payload, discovered_paths)
            
            if payload_result['success']:
                result['successful_payloads'].append(payload_result)
                result['success'] = True
                logger.info(f"✓ Payload successful: {payload.get('name')}")
            else:
                result['failed_payloads'].append(payload_result)
                logger.debug(f"✗ Payload failed: {payload.get('name')}")
        
        # Add to results history
        self.results.append(result)
        
        return result
    
    def _execute_payload(self, payload: Dict, discovered_paths: List[Dict] = None) -> Dict:
        """Execute a single payload"""
        payload_result = {
            'name': payload.get('name'),
            'method': payload.get('method', 'GET'),
            'success': False,
            'attempts': [],
            'proof': None
        }
        
        # Get paths to try
        paths_to_try = self._get_paths_to_try(payload, discovered_paths)
        
        logger.info(f"Trying {len(paths_to_try)} path variations for payload: {payload.get('name')}")
        
        # Try each path
        for path in paths_to_try:
            attempt = self._attempt_exploit(path, payload)
            payload_result['attempts'].append(attempt)
            
            if attempt['success']:
                payload_result['success'] = True
                payload_result['proof'] = attempt['proof']
                payload_result['successful_url'] = attempt['url']
                break
            
            # Small delay to avoid overwhelming the target
            time.sleep(0.1)
        
        return payload_result
    
    def _get_paths_to_try(self, payload: Dict, discovered_paths: List[Dict] = None) -> List[str]:
        """Generate list of paths to try for this payload"""
        paths = []
        
        # Add payload's predefined paths
        paths.extend(payload.get('paths', []))
        
        # If we have discovered paths, combine them with payload paths
        if discovered_paths:
            # For path traversal attacks, prepend discovered paths
            if payload.get('method') == 'GET':
                for discovered in discovered_paths:
                    discovered_path = discovered.get('path', '')
                    
                    # Only use accessible paths
                    if discovered.get('status') in [200, 301, 302, 403]:
                        for payload_path in payload.get('paths', []):
                            # Combine discovered path with payload
                            combined = discovered_path.rstrip('/') + '/' + payload_path.lstrip('/')
                            if combined not in paths:
                                paths.append(combined)
        
        return paths
    
    def _attempt_exploit(self, path: str, payload: Dict) -> Dict:
        """Attempt to exploit a single path"""
        url = urljoin(self.target, path)
        method = payload.get('method', 'GET').upper()
        headers = payload.get('headers', {})
        data = payload.get('data')
        
        attempt = {
            'url': url,
            'method': method,
            'success': False,
            'status_code': None,
            'response_size': 0,
            'proof': None
        }
        
        try:
            # Execute request
            if method == 'GET':
                response = self.session.get(
                    url,
                    headers=headers,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=False
                )
            elif method == 'POST':
                response = self.session.post(
                    url,
                    headers=headers,
                    data=data,
                    timeout=self.timeout,
                    verify=False,
                    allow_redirects=False
                )
            else:
                logger.warning(f"Unsupported method: {method}")
                return attempt
            
            attempt['status_code'] = response.status_code
            attempt['response_size'] = len(response.content)
            
            # Validate response
            validation = payload.get('validation', {})
            if self._validate_response(response, validation):
                attempt['success'] = True
                attempt['proof'] = self._extract_proof(response, validation)
                logger.info(f"✓ Exploit successful: {url}")
            
        except requests.exceptions.Timeout:
            logger.debug(f"Timeout: {url}")
        except requests.exceptions.RequestException as e:
            logger.debug(f"Request error for {url}: {e}")
        except Exception as e:
            logger.error(f"Unexpected error for {url}: {e}")
        
        return attempt
    
    def _validate_response(self, response: requests.Response, validation: Dict) -> bool:
        """Validate if exploit was successful based on response"""
        if not validation:
            # No validation specified, consider 200 as success
            return response.status_code == 200
        
        validation_type = validation.get('type', 'content')
        
        if validation_type == 'content':
            # Check if response contains expected pattern
            pattern = validation.get('pattern', '')
            if pattern:
                # Try regex match
                try:
                    if re.search(pattern, response.text):
                        return True
                except:
                    # Fallback to simple string match
                    if pattern in response.text:
                        return True
        
        elif validation_type == 'status':
            # Check status code
            expected_status = validation.get('status_code', 200)
            return response.status_code == expected_status
        
        elif validation_type == 'header':
            # Check for specific header
            header_name = validation.get('header_name')
            header_value = validation.get('header_value')
            if header_name in response.headers:
                if header_value:
                    return response.headers[header_name] == header_value
                return True
        
        return False
    
    def _extract_proof(self, response: requests.Response, validation: Dict) -> Dict:
        """Extract proof of successful exploitation"""
        proof = {
            'status_code': response.status_code,
            'content_length': len(response.content),
            'headers': dict(response.headers),
            'snippet': None
        }
        
        # Extract relevant snippet from response
        if validation.get('type') == 'content':
            pattern = validation.get('pattern', '')
            if pattern:
                try:
                    match = re.search(pattern, response.text)
                    if match:
                        # Get context around match (50 chars before and after)
                        start = max(0, match.start() - 50)
                        end = min(len(response.text), match.end() + 50)
                        proof['snippet'] = response.text[start:end]
                        proof['matched_pattern'] = pattern
                except:
                    # Fallback to first 200 chars
                    proof['snippet'] = response.text[:200]
        else:
            # Just get first 200 chars
            proof['snippet'] = response.text[:200]
        
        return proof
    
    def execute_multiple(self, exploits: List[Dict], discovered_paths: List[Dict] = None) -> List[Dict]:
        """Execute multiple exploits"""
        results = []
        
        for exploit in exploits:
            result = self.execute_exploit(exploit, discovered_paths)
            results.append(result)
            
            # Small delay between exploits
            time.sleep(0.5)
        
        return results
    
    def get_successful_exploits(self) -> List[Dict]:
        """Get all successful exploits from history"""
        return [r for r in self.results if r.get('success', False)]
    
    def export_results(self) -> Dict:
        """Export exploitation results"""
        successful = self.get_successful_exploits()
        
        return {
            'total_exploits': len(self.results),
            'successful': len(successful),
            'failed': len(self.results) - len(successful),
            'by_severity': {
                'critical': len([r for r in successful if r.get('severity') == 'critical']),
                'high': len([r for r in successful if r.get('severity') == 'high']),
                'medium': len([r for r in successful if r.get('severity') == 'medium']),
            },
            'results': self.results
        }
